Media Max Japan      （ 7）月（18 ）日 氏名（松浦　賢孝        ）
 
面接者様向け 論理的思考演習問題 (所要時間：15 分)  ──────────────────────────────────────── 
 次の (1)～(3) は、全て前文の前提と、最後の 1 行の結論が書かれている。 
 前提のみから結論を言えるか、言えないか、を答えなさい。 また、何故その答えなのか言いなさい。 
 
(1) 手形には為替手形と約束手形がある。
　　いずれも有価証券である。 
　　小切手は為替手形と似た性格を持つが、その経済的機能が異なるから、手形とは 区別される。 
　　だから、小切手は有価証券とはみなされない。 
 
 A：言えない
 　小切手は有価証券であるということを否定するには
 　小切手は為替手形と似ているが、手形とは 区別される
 　かつ、有価証券の区分が手形であるという情報が必要になる為
 
 
 
(2) フグの肝臓にはテトロドトキシンが含まれる。 
　　これは運動麻痺を引き起こし、重症の場合には呼吸麻痺により死亡する。
　　しかし、フグにはテトロドトキシン以外の毒は見出されていない。 
　　だから、肝臓を取り除いて食べれば、フグも安全である。

A:言えない
　フグの肝臓はテトロドトキシンを含むが
　フグの肝臓以外がテトロドトキシンを含まないという条件が無い為
 　
 
  
(3) ある行為が犯罪とされるためには、 その行為が刑法で定められた犯罪の型にあてはまり、
　　かつ、 正当防衛のように違法性が阻却される理由もなく、
　　かつ、 その行為を為した人に責任を帰することができるのでなければならない。 
　　その観点から、たとえば借金を踏み倒すといった債務不履行を見てみると、
　　債務 不履行は刑法が定める犯罪の型には該当しない。 
　　だから、債務不履行は犯罪ではない。 

A：言える
　犯罪の条件に債務不履行は、一部しか達成しておらず、十分ではない為


プログラミング課題 (標準時間 30 分)
以下の問題を解くコードを記述してください。
コードはどんなプログラミング言語（疑似コード含む）で書いてもらっても結構です。
コードの正確性は問いません。
アルゴリズム的に正しいかどうか、非効率なアルゴリズムでないかという点が評価の対象
となります。

1. 正の数、負の数を両方含みうる integer 配列 a が与えられたときに、
その中から最もゼロに近い数値を一つ返す関数を書いてください。
例：
a = [ 1, 3, -2 ] => 戻り値 = 1
a = [ -2, 3, 4 ] => 戻り値 -2


回答：

function NearZero(integer a[]) 

int[] List = a

begin

    poz = bisect_left(List)
    Number = 0
    if poz == 0:
        return List[0]

    if poz == len(List):
        return List[-1]

    before = List[poz - 1]
    after = List[poz]

    if after - Number < Number - before:
       return after
    else:
       return before


end



2. 正の数のみを含む二つの integer 配列 a1 および a2 が与えられたとき、
どちらか片方のみに含まれる要素の配列を返す関数を書いてください。
戻り値の配列の要素の並びは特に気にしません。
例：
a1 = [ 1, 7, 3, 2 ], a2 = [ 7, 6, 1 ] =>
 戻り値 = [ 3, 2, 6 ]


回答：

function number_not_included(integer a1[],integer a2[]) 

begin

 while a1 then
   if not a1 in a2
    List = a1

 end
  return List


end

3. 根ノード r を持つ二分木 t が与えられたときに、
木の「深さ」を計算する関数を書いてください。
ただし、木の深さとは、根ノードから最も遠いノードまでの距離として定義されます。
また各ノードは left, right という二つのプロパティを持ち、
子を持たない場合は null が格納されます。

回答：
 根ノードｒ　分岐ｔ
//頂点？

//r　はLigit　leftのプロパティを持つ無い場合はｎｕｌｌ

F[t] := true
S.push(t)
Function DFS(t)
　　If F[t] = false Then,
　  　F[t] := true
　　　Foreach node u in Adj[t]
　　    If F[u] = false Then,ｄ
　　     　DFS(u)
　    　EndIf
　   EndFor
   EndIf
EndFunction



4. 巨大な数値の配列が与えられたとします。
この中から１０番目に大きな要素を見つける関数を書いてください。
ただし、入力の配列は巨大なためソートすることができません。
また、入力の配列を書き換えることはできません。

//sort
//ソートできない？

//配列を順番に１０個のバケツにいれ１０個目の値より大きいか否かで、格納していく





5. 双方向リンクリスト(doubly linked list) l が与えられたとします。
このとき、ちょうど真ん中の要素を見つける処理を、
一つのループだけを用いて記述してください。

//双方向リストのヘッダーを探す
　//ループ一つ
　//へっだーを開始ポイントとする
　

